# 汇编基础

## 8086处理器

### 指令集

#### 寄存器

 AX,BX,CX,DX,BP,SP,SI,DI它们都是16位寄存器通用寄存器
 
 其中,AX,BX,CX,DX又可以分为两个8位寄存器,分别是:
 
 AH:AL,BH:BL,CH:CL,DH:DL

CS代码段寄存器
DS数据段寄存器,可以在代码中指定使用哪个数据段寄存器,如果不指定就默认是DS
ES附加段寄存器,当一个数据段不够时,可以使用这个 
 SS栈段寄存器
 > 没有把立即数直接传递给段寄存器的指令,所以要借助通用寄存器,或者内存


FLAGS标志寄存器
> 第6位是ZF寄存器,用来表示各种运算的结果是否为零,为0就置1,否则就是0
> 第10位是方向寄存器DF,清零是正向,置一是反向
> 使用cld和std来设置

> AF是辅助进位标志
> CF进位标志位 ,执行算术运算的时候如果发生进位或者借位则CF置1,也就是溢出的时候,但是inc和dec的溢出不会导致CF进位
> DF 是方向
> IF 是可中断标志,为1时接受中断
> OF溢出标志位,这个和进位是有区别的,这个是假定运算是有符号运算,如果结果超出了目标容器所能容纳的范围就置1 .它的意思就算如果操作是按有符号来计算的话就表明这个计算已经破坏了符号位
> PF是奇偶标志位,如果计算结果的低8位有偶数个1就次位置一,否则为0
> SF表示符号位,用来表示最高位的值,0或1.很多算数运算都会操作这个位
> tf 陷阱标志位
> ZF 是零标志位

> > mov ah , 0xff ; add ah, 2   ;不会导致OF置1,0xff表示-1,   -1+2 =1 没有结果没有超出容器的-128 ~ 127的范围


 
 
 IP指令指针寄存器,只和CS一起使用,用来标识当前的指令位置,自动增加,无法操控
 
 数据暂存器用来暂存运算的结果，然后再将其存入到相应的地方，或者设置标记寄存器
 
 > 通常每个寄存器都有其特殊用途：
 > AX用作累加器，与它有关的指令一般会在长度做优化;BX用作基址寄存器，用来提供间接寻址;CX一般用作循环计数;DX用于数据索引，用于和外设之间进行数据传送
 > SI是源索引寄存器，DI是目的索引，用于数据传送操作.它们也叫做变址寄存器
 
 这四个用来特殊的寻址操作
> BX,BP基址寻址
> DI,SI变址寻址

如果要使用基址加索引的形式,就只能使用它们的组合
> [BX:SI]  or  [BP:SI]
> [BX :DI ] or [BP:DI]
> SP/BP用来寻址SS的段内容,用来表示栈。默认是以SS寄存器为段


 32位cpu的寄存器,将原来的寄存器扩展到了32位
 EAX,EBX,ECX,EDX,EBP,ESP,EDI,ESI
 
 CS,DS,ES,SS,除了这几个段寄存器外还新增了,FS和GS
 以上六个段寄存器在32或者64位寄存器中还是16位的,但是增加了一个不可访问的部分,叫做段描述符高速缓存器,由处理器内部使用,
 里面存放了,段起始地址,段的扩展范围,以及段和各种属性,比如它是代码段还是数据段,是否可写入,是否被访问过
 
 EIP
 EFLAGS,被扩展到了32位

GDTR  ;全局描述符寄存器
LDTR ;局部描述符寄存器
TR   ;任务寄存器
IDTR ;中断描述符表寄存器


 CR3,页目录基址寄存器


 64位寄存器
 在原有的32寄存器上把E变位R
 又新增了8个64位寄存器 R8-R15 它们只能作为64位处理器使用,用来替换原来的8个通用寄存器
 
 > 为了兼容原有的寄存器还保持原来的用法
 
#### 重定位
电脑加载程序会把代码和数据加载到随机的物理地址,如果直接使用物理地址,肯定会造成错误 \n
所以就使用了一种段加偏移的方法,同一个程序的代码全部使用偏移来操作数据或者做跳转调用.
8086处理器做了硬件级的支持,当一段程序执行的时候,系统设置好CS和DS,然后做跳转
8086提供了20位地址总线,但是段寄存器只有16位,所以为了支持能访问20位的物理地址,在cpu执行操作的时候,会先将段的内容整体右移一位或多位,然后再和偏移相加得到20位物理地址

### 程序启动
0xF0000 ~ 0xFFFFF的地址一般由ROM提供
0x00000 ~ 0x9FFFF 一般属于常规内存
0xA0000 ~ 0xB7FFF 由其他设备使用
0xB8000 ~ 0xBFFFF 由显卡使用
0xC0000 ~ EFFFF 由其他设备使用
开机时cs会被初始化为0xFFFF0,IP为0x0000,这样就有15条指令可被ROM做跳转使用,一般是把磁盘的引导程序加载到0x7c00处,然后跳转
但是现代的处理器会将CS初始化为0xF000,IP初始化为0xFFF0,并将剩余部分全部初始化为1,这样组合在一起就和以前的处理器兼容了,可以执行之前的老引导程序
chs 代表磁盘的寻址,磁柱,磁面,磁道.它们又被磁盘控制器划分为多个扇区,每个扇区512字节.但是每次访问都需要指定这些很麻烦
lea 为了简化chs寻址的麻烦,磁盘开发又开发了一种辅助硬件,用来简化寻址.直接用数字来代表每个扇区
作为引导扇区,最后俩个字节是0x55,0xaa用来判断扇区是否有效,如果有效就将其加载到0x0000:0x7c00处

显卡有两种模式,即字符模式和图形模式
默认初始化为80x25的字符模式



### 指令代码
byte,word,qword指令中数据宽度标识
db,dw,dd,dq声明数据时可以使用的数据宽度标识符号.分别表示位,字,双字,四字
对于db来说,无论目标平台是大端还是小端,排序之后还是这个形式,不会自动重排数据形式

目的操作数是一个可以保存值的位置,宽度是和目的操作数相关,因为结果保存在目的操作数中
并且目的操作数不能同时为内存单元
> mov 

字节和字传送指令
原始数据由DS:SI指定,目的操作数由ES:DI指定
> rep 使用cx来计数,每执行一次指令,cx减一,直到为0
> std ;将方向DF标志置1，表示反向传送
> rep movsb ;开始传送
> cld ;将方向DF清理，表示恢复正向传送
> movsw

add加法指令
> add ax,0x0001 

sub减法指令  ,因为加法也能做减法所以几乎没有处理器提供减法指令
> sub ax,bx  ;减法指令相当于下面两条指令
> > neg bx
> > add ax, bx 


乘法指令
> mul r/m8     ;ax= al 乘 r/m8
> mul r/m16   ;dx:ax=ax 乘 r/m16       ;高16位在DX
> imul  ;有符号乘法同上


无符号除法指令,可以用来计算寄存器宽度的数字,或者两个寄存器宽度的数
> div
> > div  cl  ;16位除以8位,被除数必须在AX中,商在al,余数在ah中
> > div  CX  ;;32位除以16位,被除数在DX:AX中,除数随意,商在AX,余数在DX

有符号除法指令
> idiv和div相同可以做有符号的除法


or或指令,有一个是1就为1
> or al,cl

and与指令,有一个是0就为0
> and al,cl

test测试指令,和and一样采用与,但是不会破坏操作数,只是做测试,影响标志寄存器
> test r/m8/m16 ,imm8/imm16
> test r/m8/m16,r8/r16

not 反转位指令
> not r/m8/m16

异或指令,相同为0不同为1,可以用来清空寄存器,不允许两边同时位内存.并且左边必须是一个能存数据的位置
> xor


无条件跳转
> jmp   ;jmp在执行远跳转的时候会改变CS和IP,也就是跳转的段地址和偏移地址的映射
> jmp near  $-3   ;;段内跳转,操作数是一个立即数相对于当前指令位置的偏移.如果带上段基址就是远跳转,近跳转占3个指令长度
> > far和near 是不必要的,只有段就是长跳转,否则就是偏移
+ 1，相对短跳转
> jmp short  1字节偏移  ; 相对于当前指令位置的偏移，只有一个字节。-128~127

2，相对近跳转
> jmp near  2字节偏移 ；相对于当前指令的偏移，-32768~32767

3，16位间接绝对近跳转，相对于段的偏移
> jmp near bx      ;默认就是near所以可以省略，偏移由bx指定
> jmp near  [bx]  ;偏移由bx指定的内存中的值指定

4，16位直接绝对远转移，跨段
> jmp 段:偏移    ;直接给出段和偏移

5，16位间接绝对远转移，内存给出段和偏移
> jmp far [bx+si]   ;段和偏移由指定的寄存器指向的内存的内容给出。 far是必须的
> jmp far [0x0003] ;段和偏移由指定位置的内存中的值给出


jcc指令簇,有条件跳转,它们都是需要一个立即数,表示段内偏移量.指令里的n,代表!=1的时候
> js/jns            ;根据SF做跳转
> > jns offset  ;跳转到偏移,如果SF位为0就跳转,否则不跳转
> jo/jno           ;OF
> jc/jnc            ;CF
> jp/jnp           ;PF

cmp,也是将两个数相减,不会改变原有容器的内容,仅仅是用来测试一下,从而影响标志位
> cmp的操作数可以为同为内存,它会影响六个标志位,是拿目的操作数和源操作数比


循环
loop 只有一个字节,将cx减1,如果不为0就跳转到指定偏移
> loop 偏移  ;


自增自减
> inc al  ;将al寄存器内容自增1
> dec  byte [bx]  ;将bx指定的内存里的数据减1

零-  0-n用零减去一个数的指令,用来得到一个负数  0 - 127 = -128  => 11111111
> neg al   ; 0 - 00000001 = 11111110 = -1
> neg dx 

符号扩展cbw 没有操作数,将AL中的符号位扩展至AX
> 正数在使用中没有什么太大的影响,但是如果是负数,因为高位代表符号位,如果8位16位和32数据进行互操作的话就会有问题了
> cwd ;没有操作数,将AX的符号扩展至DX组成DX:AX

push,压阵指令,栈的布局是逆增长
> push ax   ;16位8086cpu上只能压入16位的寄存器或者内存单元 ;32位,64位可以压入相同宽度的
> > push压入栈的位置是SS:SP指定的,步骤是先将SP减去指定宽度,若SS段被初始化位0x0000,SP初始化为0x0000,那么组合在一起的物理地址就是0x00000
> > 将SP-2 就是0xFFFE,和SS段组合在一起就跳到这个段的高位了

pop,弹出指令,要求和POP一样
> pop ax ;将ss:sp位置的数据弹出到ax,然后SP减去数据宽度


pushf/pushd/popf/popfd  将FLAGS寄存器压栈/出栈
> 事实上在16位模式下不仅可以压入16位FLAGS寄存器,还可以压入32位的EFLAGS寄存器,只要使用0x66指令前缀就行了
> 但是在32位模式下,只能压入32位的EFLAGS,即使使用了0x66前缀也一样
> popf/popfd也是一样

in/out独立编址端口操作指令
> in al , dx ;这里的dx并非错误，而是必须如此，为了简化指令，不允许使用其他寄存器
> > 目的操作数只能是al或ax , 源操作数必须是dx间接寻址或者8位立即数
> out  dx,al   ;这里的dx并非错误，而是必须如此 
> > 目的操作数必须是8位立即数或者dx间接寻址，源操作数必须是al或者ax





xchg 数据交换指令
> xchg r32,m32  ;源操作数和目的操作数都可以是受支持大小的寄存器,内存,但是不允许两边同时为内存

四种过程调用
+ 1，16位相对近调用,相对于指令位置偏移。只能是立即数
> call near proc1/或者偏移量；这个偏移量可以为负在区间-32768~32767  。near是非必须的，默认为相对近调用
> > 会将IP压栈，然后改变IP指针，这样执行下一条指令的时候就会从指定位置执行

+ 2，16位间接绝对调用，相对于当前段的偏移,并且是通过中介找到偏移地址。可以是寄存器或者内存
> call  [0x3000]
> call cx

+ 3，16位直接绝对远调用，跨段调用。直接的意思是段地址和偏移直接在指令给出
> call 0x2000:0x0300
> > 首先将CS内容压栈，接着将IP内容压栈，然后立即开始执行下一条指令，导致代码跳转到指定位置执行，这些操作一气呵成

+ 4，16位间接绝对远调用，调用的段和偏移被间接存在另一个地方。间接提供段和偏移时，偏移在前，段在后
> call far  [0x2000] ;far关键字是必须的，从指定的偏移内存中找到远调用的地址，因为段加偏移寄存器无法容纳，所有只能由内存提供


ret/retf/iret返回指令
> ret  ;只做一件事就是从call调用返回，也就是将ip地址从栈中弹出
> retf ;从call far调用返回，分别弹出IP，和CS的内容，然后执行
> 也可以在栈中压入一个IP和段，然后可以直接调用ret/retf返回到一个位置
> iret 从中断中返回,将IP,CS,FALGS三个寄存器的内容弹出
> ret/retf  imm16  ;在返回时,可以弹出指定数量的字节



改变可中断状态
> sti/cli  ;用来设置或者清除中断标志


移位指令
+ shr 右移,移出来的位送往标志寄存器的CF
+ shl左移，指令格式相同
+ ror/rol循环右/左移动，移出的位同时送往CF和操作数最左/右的位置，和shl/shr指令格式相同
> r/m8/m16,1   ; 源操作数为1的形式是特殊优化的设计
> r/m8/m16,imm8
> r/m8/m16,cl

hlt处理器休眠指令
>hlt


 32位 新增指令
> movsd ;指令格式相同,一次传送双字

cpuid获取cpu信息,80486后期开始引入
> cpuid   ;用eax指定要获取的信息,返回值可能会用到EAX-EDX

cmov cc  条件传送指令,P6处理器开始引入.可以避免使用转移指令带来的处理器执行速度下降,因为每次使用转移都会导致预取的和缓存的指令失效
> 用于带条件的数据传送. 传送和条件分支合成在一个指令周期中.目的操作数只能是16/32位通用寄存器 ,源操作数只能使用相同宽度的寄存器或者内存
> cmovz ax,cx   ;为零则传送
> cmovnz  eax,[0x2000]   ;非零则传送
> cmove ebx,ecx    ;相等则传送
> cmovng  cx ,[0x1000]  ;不大于则传送
> cmovl  edx,ecx  ;小于则传送
> cmov cc指令可以在条件转移指令的基础上将首字母j换成cmov即可

movzx/movsx  无符号传送/有符号传送指令
> movsx r16/r32 , r/m8/m16  ;使用最高位的符号位扩展,目的操作数只能是16或者32位通用寄存器,源操作数只能是8位或者16位通用寄存器或者内存单元,宽度可以不一样

cmpsb/cmbsw/cmpsd    字节/字/双字内容比较指令,执行相减,根据结果相应的标志位,只比对一次,一次的宽度由指令决定.使用DF标志位指定比对方向,为1表示反向
> cmpsb    ;源字符串地址使用DS:EDI   目的字符串地址使用ES:EDI指定,比对一次后ESI和EDI的内容分别减去指令比对的宽度

repe/repne/repz/repnz 条件重复指令,除了(E)CX =0 外还有其他终止条件
> repe/repz   cmpsb  ;  ZF=0时终止
> repne/repnz  cmpsw ; ZF = 1时终止


xlat 处理器查表指令,也可以在16位模式下使用
> 事先在DS:(E)BX处定义一个用于转换编码的表格,指令执行时,用AL寄存器的内容作为偏移量查找此表格,然后取出对应的内容放入AL寄存器.可以用来做ascll码映射表


不同特权之间的代码转移
> 不允许直接将控制权从高级别跳转到低级别,特权代码段的转移只能通过调用门返回
> jmp far  调用门;使用原任务的特权级
> call far  调用门;使用目标任务的特权级,并且切换到对应的特权级栈
> > 每个任务都有额外的栈用作切换时使用,比如特权3的任务需要额外的栈段描述符,分别是0,1,2. 而特权2 则需要额外的0,1.切换到特权几就使用对应的特权栈

任务切换,任务是不可重入的
> call   ;如果是任务门,那么call的方式类似于因为中断引起的嵌套任务
> jmp   ;进行任务切换时,不会引发嵌套.

iretd
> 其实就是iret  ;这是编译器自造的指令,当在16位模式下使用时,会自动在前面加上0x66,在32位下则不加

位串测试指令
> bts  r/m16/m32  , r16/32   ;源操作数只能是寄存器,将指定的位值传送到CF位,然后将其置位
> btr  ;将指定的位值传送到CF标志位,然后将其清零
> btc  ;传送到CF,然后将原来的位取反
> bt    ;将指定的位传送到CF标志位

wait/fwait  用于cpu和fpu之间的同步,用在浮点指令之后,以捕获任何浮点异常

bound,检查数组是否越界
> bound r16/r32, m16/m32  ;数据宽度要匹配
    > > 目的操作数是数组的索引,源操作数必须指向内存位置,这个位置包含的数组的上下限,如果目的索引越界则产生异常

ud2 引发无效操作码异常
> ud2   ;没有操作数 0F 0B. 在转入异常处理的时候,压入栈中的指令是当前的指令地址

invlpg 刷新TLB中的单个条目
> invlpg m;必须是内存

### 伪指令
> times n  mov ax , bx  ;times重做后面的指令n次
> times n db 0  ;留出n个字节的数据用零填充
> resb/resw/resd  256;留出 指定数量的字节，字 ，双字空间，但是不初始化

### 数据传送
> data1 db 0x55, 0x56 ;声明一段空间,大小为字节
> mov ax , 0xb800
> mov es , ax        ;将地址0xb800加载到段寄存器es
> mov byte [es:0x00] , 'L'   ;像指定定制写入字符L   ;之所以带方括号,因为告诉cpu目的操作数是一个间接寻址,是要把字符放入寄存器指定的地址中,而不是寄存器中,也就是需要二次寻址
> mov ax , [0xb800] ;如果不加数据段,默认是ds
> 数据宽度无法判断的时候才需要加上宽度标识


### 端口
intel早期是独立编址的，现在还添加了内存映射
> 在独立编址的端口中M/IO# 引脚控制访问的是内存还是端口
> > M/IO#表示低电平有效，当此引脚呈低电平时，表明之后的内存操作是操作的端口号

> 端口0x92用来屏蔽A20#,已经影响INIT#引脚.进而初始化处理器,引发重启

> 对于端口来说,本质上是每次操作一个数据,但是一次向多个端口读取数据,可以做到每次读取一个字或双子

### 中断.除了NMI中断,只用于控制硬件引发的中断,处理器是否接受还是看IF位
外部硬件中断
早期外部硬件中断,由两个引脚发生. 注意中断和端口是不一样的
> NMI 非屏蔽中断,不可屏蔽, 分为RAM#(内存校验错)和LOCHK#(I/O校验错)  ;2号中断向量.一旦发生就是不可继续执行的那种
> INTR 可屏蔽中断 ,该处理器引脚最多支持256个中断
> > 8259中断芯片负责中断的分发,负责其中的十五个,8259有自己的映射端口,可以用来操作这个芯片
> > > 主片端口号0x20,0x21  ; 从片端口号0xa0,0xa1
低级中断是可被高一级别的中断中断的,这称为中断套嵌
> 中断发生时,首先将FLAGS压栈,接着清除TF和IF位,然后将CS和IP压栈,这些操作一气呵成,然后根据中断号到中断向量表中找到处理程序的入口点执行
> 默认的中断都指向同一个处理程序,只有一条代码iret

> 0x70和74是索引端口, 0x71和0x75是数据端口;它们是cmos ram 的访问端口 
> > 0x70的最高位7bit 用于控制NMI中断的开关,为1时阻断所有NMI中断

内部中断,是由处理器内部引发的,不受IF位影响,不需要中断识别总线周期
> 比如除法错,或者指令错,这些中断类型都是固定的,一旦发生即可转入相应的处理

软中断,由int指令引起的中断,中断号直接在指令中给出,也不需要中断识别总线周期
> int  imm8  ;引发指定中断,指令码CD

> int3  ;断点指令,单字节指令,指令码CC,用于断点调试,需要设置中断时,可以将相应地址处的指令的第一字节码改成CC,再保存原子节
> > 当执行到这条修改过的指令时,会发生3号中断,然后跳转到相应的中断处理程序,处理程序将所需要的信息压栈,然后再操作显式这些信息
> > 之后将修改后的那条指令复原,然后修改栈中的地址,调用iret返回

> into ;单字节指令,机器码CE.执行这条指令时,如果OF溢出位为1,则进入4号中断,否则什么也不做


BIOS中断,调用BIOS提供的功能
> mov ah,0x00   int 0x16 ;调用键盘服务.一般使用ah指定要使用的功能.返回时,al存放着按键的ascll码
> mov ah,0x0e   int  0x10 ;向屏幕写一个字符
> 具体可以自己查询参考资料






## 32位86处理器
intel 32位处理器架构简称IA-32,以8086位基础发展起来的,通用寄存器和地址线都是32位
8086处理器只有一种实模式
而新款的处理器有两种模式,分别是实模式和保护模式

寄存器在原有的基础上扩展至32位
EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP
EIP 

EFLAGS
> 第21位是cpuid指令支持位,如果为1表示支持cpuid指令
> NT位 ;第14位表示任务嵌套

段寄存器,在保护模式下,它们叫做段选择器.每个段寄存器还有隐藏部分,叫做段描述符高速缓存器
CS,SS,DS
新增了FS,GS

> 低16位和原先一样,但是在32位模式下用法不一样
>而且这些段寄存器还增加了一个64位的隐藏部分用来缓存段描述符
> 保护模式下,不允许使用mov指令改变cs段寄存器的内容,只能使用跳转

> 一般而言指令的操作数要大小一直
> 32位寄存器的高16位不可独立使用,但是16十六位和以前的使用方式一样

实模式下一个程序可以完全访问全部地址线所提供的数据量
无论在哪种模式依然处理器依然是采用的分段模型,但是可以只分一个段

保护模式
在保护模式下传统的段寄存器不再,保存段,而是段选择子

分页
> 在未启用分页时,在指令种给出偏移的意思是将段内容加上这个偏移来指定物理地址,但是在分页启用后,段加偏移指定的就是线性地址,还需要转换才能找到实际的物理内存地址

临时寄存器
> cpu内部有大量临时寄存器,用来支持乱序执行



指令的变化
> shr/shl指令为改变,如果使用寄存器,必须是cl;
> > shl eax,cl   ;先将cl的内容同0x1f做与操作,仅保留低五位,也就是移动次数最大31

> push imm8/16/32  ;在原有的基础上支持立即数压栈
> > push压栈时,如果压入的是立即数,并且和处理器寄存器宽度不匹配,那么会自动被扩展置相同的位数
> > 如果压入的是内存,那么只能压入16位或者32位寄存器或者内存单元
> > 压入段寄存器的情况比较特殊,CS,DS,SS,ES,FS,DS,32位模式下压栈时,先将段寄存器用0扩展至32位,然后压入32位的值

加载全局描述符,这是特权指令
> lgdt m48
> lldt  r/m16段选择子 ;加载局部描述符表,段选择子是在全局描述符表中的位置
> ltr  r/m16 段选择子 ;加载任务寄存器
> sgdt  m46   ;将GDTR(全局描述符表)寄存器的内容保存到指定的内存中
> lidt  m48  ;加载中断描述符表


> arpl ;用于支持操作系统做特权隔离,操作RPL字段

CR0到CR8寄存器,控制处理器的操作模式和运行状态
> cr0第一位置1会导致处理器立即进入保护模式




bswap ,按字节互换指令.如:低8位换到高28位,然后中间的那些字节也两两互换
> bswap r32 ;只允许32位寄存器

## 总结

### 指令对标志寄存器的影响
一般只有std/cld影响DF
并且一般只有进行逻辑运算的操作才会影响标志
    add/sub:  AF,CF,DF,OF,PF,SF,ZF
    std/cld:    只影响DF,其他的都是未定义,也就是仅仅目前此指令不影响其他标志位,不要依赖这些标志位
    inc/dec:   CF不受影响,其他视情况而定. 因为CF通常用于循环计数,不希望此指令影响循环的操作
    imul/mul:          如果结果高的一半全为0 则OF 和CF清零，否则置1;
    div/idiv:        未定义
    neg:               主要影响CF,其他视情况而定 
    xor:                OF =0 ,CF=0,其他视结果而定,AF未定
    or:                  OF=0,CF=0,其他视情况而定,AF未定义
    and:               OF =0 ,CF =0,其他视情况而定,AF未定义
    not:                不影响
    test:                OF=CF=0,其他视情况而定,AF未定义
    cbw/cwd:     不影响
    cmov cc:       不影响,但是依赖这些标志
    bt系列:           只影响CF,其他不影响,或者未定义
### cmp的比较结果和跳转指令
> cmp ax,bx

根据指令关注的符号位,把指令化分为有符号和无符号

指令       比较结果      英文描述       相关标志位状态
> je      ; =    equal    相减结果为零,ZF=1
> jne   ;!=    not equal ZF =0 
> jg     ;>      greater     适用于有符号比较. 要求:ZF=0,并且SF=OF
> jge   ;>=    greater or equal   适用于有符号比较.   要求:SF=OF
> jng   ;!>     not greater     适用于有符号比较.  要求ZF=1,或者SF!=OF
> jnge ;!>=   not greater equal  适用于有符号,要求SF!=OF
> jl       ;<       less    适用于有符号数,等于!>=,要SF!=OF
> jle     ;<=     less or equal      适用于有符号,相当于!>,要求也一样
> jnl     ;!<      not less          适用于有符号, 等同于>=
> jnle   ;!< =   not less or equal  适用于有符号  等同于>
> ja      ; >       above    适用于无符号,要求: CF=0,ZF=0
> jae    ;>=      above or equal  适用于无符号,要求CF=0
> jna    ;!>       not  above      适用于无符号整数,等同于< =,要求:CF=1 或者ZF=1
> jnae  ;!>=     not above or equal   适用于无符号,相当于<,要求CF=1
> jb      ;<         below         适用于无符号,要求CF=1
> jbe    ;< =      below or equal   适用于无符号,要求CF=1,或者ZF=1
> jnb   ;!<         not below      适用于无符号,等同于 >=
> jnbe ;!<=      not below or equal  适用于无符号,等同于 >
> jpe    ;校验偶  parity even    要求:pf=1
> jpo    ;校验奇  parity odd     要求:pf=0
> jcxz    ;自助跳转指令   jump if cx is zero     根据cx寄存器的内容如果是零就跳转




### 寻址方式,怎么获得操作数

寄存器寻址
> 操作数位于寄存器中

立即数
> 操作数包含在指令中，不需要寻址

直接内存寻址，直接写入内存地址
> mov ax,[0xb800]   ;数据在ds的一段内存偏移中

间接内存寻址，也叫基址寻址。通过寄存器来提供内存地址
> mov [bx],dx   ;将dx的内容传送到ds:bx所组成的内存中
> mov [bx-10],ax  ;可以提供一个立即数偏移量，这不会改变bx寄存器，仅仅是又来寻址的时候-10

变址寻址使用SI，DI
> 和基址寻址一样   ；默认使用DS段，也可以加一个立即数

基址变址寻址,使用一个基址寄存器加一个变址寄存器，可以外加一个立即数,16位cpu不允许缩放因子
> mov ax,[bx+si+0x10]


32位寻址
> 与8086不同,32位cpu可以使用全部通用寄存器作为基址,加上除ESP之外的32位通用寄存器作为变址寄存器,变址寄存器可以乘以一个1,2,4,8的缩放因子,再加一个8或32位的偏移量
> > mov ecx , [eax+ebx*2+0x33]
> mov ax ,[sp]  ;error  在16位模式下这条指令是错的,因为不能使用sp作为间接内存寻址
> mov eax,[ESP]  ;32位模式下可以

指令寻址大小问题
> 为了指定寻址的大小 指令前加0x66,改变寻址大小,用来在当前模式取反寻址操作,比如
> > 如果cpu工作在16位模式,如果前面不加0x66那就是16位寻址,否则就是32位寻址模式
> > 如果cpu工作在32位模式,如果前面不加0x66那就是32位寻址,否则就是16位寻址
> > 以上都是用来操作寄存器的
> > mov eax,[bx] ;如果想要在32位模式下使用16位有效地址就需要在指令前加0x67

指令前缀
> 每条指令都可以拥有一到四个前缀,每个前缀1字节,也可以没有
> rep/repe/repne 重复前缀
> lock  总线封锁前缀



###  nasm的标识符
> $ 表示当前所在内容相对于段的位置
> $$ 表示当前所在段的位置
> 这里的段是.text这种,不是寄存器段
> section 段名称 align = 16 vstart=0  ;创造一个段,编译器并不关系段的用途，一旦定义一个段，后面的内容就属于这个段，除非遇到另一个段
> > align表示对其要求
> > vstart 表示启用数据在声明段中的偏移,使用这个符号之后,所有段内的偏移都是以相对于段内的。因为如果没有这个，即使定义了段，标记的偏移还是基于整个文件的
> > intel cpu要求段要16位对齐，也就是 物理地址%16 =0
> > section.段名称.start   获得段在整体文件中的位置
> app_start equ 100 声明一个常量，不占任何内存
> bits 32  / [bits 32] ;编译成32位指令,用在文件开头表示后面的指令编译成指定模式.这两种声明方式都可以,如果不指定就是默认的16位模式

### 设备分类
块设备就是一次要读一个块
字符设备就是按字节传输数据

串口是数据使用一个流操作
并口是数据同时使用多个流操作

索引端口，由于显卡的寄存器太多，无法直接全部映射到I/O空间，所以可以通过索引端口号来解决
> 0x3d4 ;设置操作的显卡端口
> 0x3d5 ;进行操作


磁盘访问
> chs模式 最原始通用
> lba28、lba48 采用28位来表示逻辑扇区号


## 8086处理器系列
> 8086 16位分段cpu.20根地址线
> 80286  16位分段cpu,24根地址线,第一次有了保护模式的概念,16位保护模式.合成物理地址时,不再需要左移,也不要求非得位于16位对齐,通用寄存器是16位
> 一般情况下实模式和16位保护模式值的是8086模式
> 80368  32位分段cpu,是后续所有32位产品的基础,寄存器32位,地址线32位,最大可访问4g内存,可以运行实模式下的8086程序,加电自检时,默认为实模式
> > 32为保护模式兼容16位保护模式
> > 还提供了一个v86保护模式,可以将处理器模拟成多个并行处理的8086处理器,也是保护模式的一种,一般要执行8086的程序必须要在实模式下
> > 引入分页


> 80486开始有了A20#引脚,它是低电平有效的,用来频闭A20地址线.
> > 处理器默认频闭A20地址线,需要手动将A20#引脚置高电平来打开,具体做法是写0x92端口
> > 开始包含浮点运算部件 x87FPU

## 调用规则
stdcall
> 参数从右到左进栈,由被调过程弹出栈
