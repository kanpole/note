# 汇编指令及代码实例

## 寄存器

EAX,EBX,ECX,EDX,EBP,ESP,ESI,EDI

其中EAX,EBX,ECX,EDX低16位可做单独寄存器,去掉E前缀.并且每个又可分为两个8位寄存器如:AH和AL. \n
但是高16位不能单独使用

CS,DS,SS,GS,ES,FS
EFLAGS
EIP

MMX,8个64位寄存器,用来实现SIMD,用来实现数据的并行操作,实际上共用的浮点寄存器

XMM,8个128位寄存器,它们用于SIMD流扩展指令中
有浮点运算单元,从80486开始集成到CPU中
ST(0)  ~  ST(7) ,是8个80位浮点寄存器

64位处理器中
16个64位通用寄存器,原先的加上R8 ~ R15
8个80位浮点寄存器
1个64位标志寄存器RFLAGS(只使用低32位)
164位指令指针寄存器RIP
8个64位 MMX寄存器
16个128位XMM寄存器 (32位只有8个)
虽然是64位地址长度,但是按照目前的实际情况,还没有那么大的内存,所以一般只使用低48位
64位模式下,操作数大小默认是32位的,但是加上R前缀后可以达到64位,REX前缀下可以用的寄存器:
可用的8位寄存器: AL,BL,CL,DL,DIL,SIL,BPL,SPL,SPL,R8L~R15L
可用的16位寄存器:AX,BX,CX,DX,DI,SI,BP,SP,R8W ~ R15W
可用的32位寄存器:EAX,EBX,ECX,EDX,EDI,ESI,EBP,ESP,R8D~R15D
可用的64位寄存器:RAX,RBX,RCX,RDX,RDI,RSI,RBP,RSP,R8~R15
> 64位模式下,单条指令不能同时访问寄存器的高字节,如AH,BH,CH,DH,以及新字节寄存器的低字节如DIL
> 64位模式下,FLAGS寄存器由64位寄存器代替,共享低32位,高32位不使用
> 32位模式和64位模式具有相同的状态标志


64位架构引入了一个新模式,IA-32e,这个模式包含了两个子模式,兼容模式和64位模式
在64位模式中,不支持16位实模式和虚拟8086模式
兼容模式下,16位和32位程序不用重新编译就可运行.但是在win上早期的16位程序不能运行,因为win没有提供虚拟支持

64位模式下,只运行那些使用64位线性地址空间的应用程序,这也是win64的原生模式,使用64位指令操作数





### 寄存器特殊用法
EAX  用做累加器,与他有关的指令一般都有特殊优化
ECX  用作循环计数
ESP  用于堆栈的指针,默认使用SS段
EBP  用于引用堆栈,默认使用SS段
ESI和EDI  用于高速存储器传输指令,用它做数据传送可以每次自动增加数据宽度
EIP  指令指针,默认使用CS段

EFLAGS  标志寄存器,用于一些操作的控制.一般常用的有:
> DF  数据方向,用于控制数据传输的方向,为0则正向传输
> CF  进位,无符号算术运算结果太大,设置该标志位
> OF  溢出,有符号算术运算结果太大或太小,设置该标志
> SF   符号标志位,算术或者逻辑运算操作的结果导致最高位为1时,设置该标志
> ZF  零标志位,算术或逻辑产生的结果为0时,设置该标志
> AC  算术操作在8位操作数中产生了位3向位4进位时,设置该标志
> PF   奇偶标志,结果的最低有效字节包含偶数个1时,设置该标志,否则清除,一般用于数据损坏的检测
> IF   中断标志位


## 指令
nop,空操作
> nop ;90,什么也不做，可以用于指令对齐到偶数倍地址

fld将数字加载到浮点堆栈
> fld  number
> fbstp mm; 将二进制编码十进制数存入指定内存

数据传送指令
+ mov
> mov dest, src
> > 操作数宽度一直，不能同时为内存，IP寄存器不能用做操作数
> 64位下，将一个32/16/8位的常数送入64位寄存器，那么会导致寄存器的高位全部清零
> 如果将32位的内存操作数送入64位寄存器的低32位，也是会清零RAX的高32位
> 如果将16/8位内存操作数送入RAX的低位寄存器如ax,al，那么寄存器的高位不受影响.其他寄存器也是一样


+ movzx/movsx,零扩展传送/符号位扩展传送
> movzx dest,src   ;src的宽度必须小于dest，位数不够使用0填充
> movsx dest,src   ;同上，但是不够的位数用src最高位的符号代替

字符串基本指令,这些指令本身只执行一次,可以配合rep前缀使用
movsb/movsw/movsd  ,一次复制字节,子,双字,也就是每次+1 ,+2 或+4
> 传送字符串:将ESI寻址的源内存操作数,传送到EDI寻址的目的内存操作数
> 执行指令时ESI,EDI自动增加,使用DF控制方向,以表示是自增还是自减
cmpsb/cmpsw/cmpsd
> repe cmpsb  ;为0则继续比较  ;后面可以跟上一个跳转指令,如果两个字串完全相同,那么结束后,zf肯定为1,of=cf=0
> 字符串比较:比较ESI寻址的内存操作数和EDI寻址的内存操作数,一般在比较后会根据结果做跳转

scasb/scasw/scasd
> repne scasb  ;不相等则重复,要查找的字符在AL/AX/EAX中,然后可以根据标志位来检查是否找到了符合的字符
> 扫描字符串:比较累加器AL/AX/EAX与EDI寻址的内存数据,EDI每次执行完自增或自减
> 可以用来在一个字符串中寻找一个值

stosb/stosw/stosd
> rep stosb;
> 保存字符串数据:将累加器的内容保存到EDI寻址的内存位置,EDI 每次自增或自减
> 可以用来初始化一片内存

lodsb/lodsw/lodsd,很少和rep指令一起使用,因为重复加载会覆盖值
> 可以用来代替mov的某些操作,比如 : mov al,[esi]    inc esi    mov [esi] , al  => lodsb  inc al   stosb 
> 从字符串加载到累加器: 将ESI寻址的内存数据加载到累加器AL/AX/EAX中
> 可以和stosb配合使用,进行加载-处理数据-保存这一流水线操作

重复指令前缀
rep/repz/repe/repnz/repne
> 使用ECX作为计数,重复执行后面的指令,ECX为0则停止,首先测试ECX是否大于0如果大于就将其减1,然后执行后面的指令
> 后面几个除了ECX>0这个条件外,还有附加条件: ZF标志为1/zf标志清零则重复

STD/CLD
> 设置方向标志位

+ LAHF/SAHF
> lahf  ;加载状态标志位到AH,将FLAGS的低字节复制到AH
> sahf ;将AH中的内容传送到FLAGS寄存器

+ XCHG,交换数据
> xchg dest,src ;交换彼此的数据，宽度必须一致

算术指令
+ INC/DEC  +/-1
> inc reg/mem  ;将操作数增加或者减少1
> > 不会影响CF,其他视结果而定

+ ADD/SUB  加减指令
> add dest,src ;宽度必须相同
> > 标志位视结果而定

+ ADC/SBB
> adc reg/mem,reg/mem/imm  ;操作数大小必须相同
> mov dl,0
> mov al,ffh
> add al,ffh   ;al =feh
> adc dl,0    ;dl:al = 1feh   ;带进位加法，就是将进位标志作为第三个操作数加进来
> sbb 和adc相同，比如被减数放在EDX:EAX中，那么先执行EAX减去操作数，如果不够就借位，导致CF标志置位，然后执行EDX减去一个数的时候就会多减去一个CF标志的值

ASCLL和非压缩十进制运算
> 十进制数 3402 
> 十进制数 1256  +
>  结果        4658  ;将值两两相加
> 对于这种方法，需要在每对ascll数据相加后用特殊指令调整
> AAA ;执行加法后进行ascll调整，紧接在add,adc之后
如：
```asm
mov ah,0  ;先清零高位
mov al,'8' ; AX = 38h
add al,'2' ; AX = 6ah
aaa        ; AX = 100h,结果进行ASCLL调整
or  ax,3030h  ;AX = 31 30h = '1' '0'  ;将每个非压缩格式与30h进行or操作就可以得到对应的ascll码

```
> AAS ;执行减法后进行ascll调整
> > 只有结果为负时调整才是必须的
> AAM ;执行乘法后ascll调整
```asm
mov bl,05h  ;必须是非压缩十进制数
mov al,06h  ;虚拟十进制的06
mul bl      ;AX = 1eh  二进制表示这个数字
aam         ;AX = 03 00 调整后的数字，对应30  相当于5*6=30

```
> AAD ;执行除法前ascll调整
```asm
mov ax,0307h   ;虚拟表示十进制3 7
aad            ;AX = 0025，除法前调整到二进制，37的二进制表示。
mov bl,5h      ;除数
div bl         ;AX=02 07  结果商是7 余数是2

```

> 对于3402  ascll码格式为: 33 34 30 32      非压缩十进制格式为: 03 04 00 02  ;每个数字代表一个字节
> > ascll加减法操作数可以为以上任意一种，但是乘除法只能是非压缩十进制格式


ASCLL码和压缩十进制数,目前还没有乘除法指令
+ DAA/DAS
> 每个字节表示两个十进制数，四位一组
> 执行压缩十进制的加减法,参与加减的必须是压缩的十进制数
> 要想执行压缩十进制的乘除法，必须使用非压缩的指令，执行后再压缩
> 这些压缩或者非压缩的十进制指令的操作数和结果都在AL或者AX
```asm
mov al,48h
add al,35h   ;al=7dh
daa   ;al=83H   加法后调整的结果
```

+ NEG ,相当于非指令，将操作数变为相反数
> neg reg/mem ;将目标操作数取反再加一，相当于用0减去操作数
> > 其他标志位视结果而定，非零操作数上应用此指令，总是设置进位标志位

> 64位模式下如果使用低位寄存器进行算术运算，然后溢出或者进位时，不会进位到高位，而是直接舍弃，溢出也是

跳转指令
+ jmp dest ;跳转到指定位置开始执行


循环指令
+ LOOP
> loop dest ;计数放在cx中，先CX减1，判断是否为0，不为0跳转到指定偏移。范围-128~127
> >loopd使用ECX，loopw使用CX，默认loop使用当前模式适用的寄存器

+ LOOPZ/LOOPNZ/LOOPE/LOOPNE，loopz=loope,它们有相同的操作码，其他两个也是彼此相等的
> 除了CX计数寄存器条件外，还增加了标志寄存器的终止条件


push/pop
> push reg/mem16/32/imm32  ;将esp减去相应数据宽度，然后将数据压栈
> pop reg/mem16/mem32  ;将数据弹出，然后将esp加上相应宽度
> pushfd/popfd 将FLAGS寄存器压栈/出栈，没有操作数
> pushad/pusha,popad/popa
> > pusha/popa  将AX,CX,DX,BX,SP,BP,SI,DI依次压栈/出栈。在16位模式下只能使用这俩
> > pushad/popad 将EAX,ECX,EDX,EBX,ESP(执行该指令之前的值),EBP,ESI,EDI顺序压栈/出栈

LEA 计算偏移指令
> mov [0x005] , 'a'  ; 这个地址存放了a字符
> mov ebp,0x001; 设置ebp的值
> mov esi ,[ebp+4] ;  esi  = 0x001+ 4 = a  从这个地址取出值存放在esi
> lea esi ,[ebp+4]  ;esi  = 0x005  ;只使用变址来计算地址但是不取值

ENTER/LEAVE
> enter numbytes,nestringlevel   ;两个都是立即数,前者是向上舍入的4的倍数,也就是局部变量的总大小 . 后者指定了从主调栈帧复制到被调栈帧的指针个数
> > enter  8,0   ;局部变量总大小为8,首先把ebp入栈,然后将ebp = esp,然后将esp减8,预留局部变量空间
> leave ;无参数,反转enter的操作
> 用于被调过程自动创建堆栈/清理堆栈
```asm
enter 8,0
 ...
 ...
leave

相当于:

push ebp
mov ebp,esp
sub esp,8
.
.
mov esp,ebp
pop ebp
ret

```

布尔指令
+ AND
> and reg/mem , reg/mem/imm  ;宽度必须相同
> 进行逻辑与操作
+ OR
> 进行逻辑或操作
> 和AND相同
+ XOR
> 和AND相同
> 进行逻辑异或操作
+NOT
> not reg/mem ;反转所有位，不影响标志
> 逻辑非
+ TEST
> 和AND相同，但是不修改操作数
> 非破坏性逻辑与操作，并设置相应标志位

> 64位下执行布尔指令时，如果目的操作数是RAX或者内存，源操作数是小于32位，那么目的操作数的所有位都会受到影响  \n
> 如果源操作数是32位内存或者寄存器，那么只有低32位会受到影响

CMP指令
> cmp dest,src ;从目标操作数减去原操作数，但是不修改任何值，只设置标志位

Jcond指令
+ JC/JNC
> jc dest  ;进位跳转
+ JZ/JNZ
> jz dest ;为0跳转
+ JO/JNO
> 溢出跳转
+ JS/JNS
> 符号跳转
+ JP/JNP
> 奇偶跳转
> > 上面是条件跳转

相等性跳转
JE/JNE
> 相等/不相等跳转

JCXZ/JECXZ/JRCXZ
> cx/ecx/rcx为0跳转

无符号相等性跳转
+ JA/JB
> 大于/小于跳转
+ JAE/JBE 
> 大于等于/小于等于跳转
+ JNA/JNB
> 不大于/不小于跳转
+ JNAE/JNBE
> 不大于等于/不小于等于跳转

有符号相等性跳转
+ JG/JL
> 大于/小于跳转
+ JGE/JLE 
> 大于等于/小于等于跳转
+ JNG/JNL
> 不大于/不小于跳转
+ JNGE/JNLE
> 不大于等于/不小于等于跳转

> > 通常test用于测试位的开闭，而cmp用于测试两个数的相等性





移位指令
+ SHL/SHR
> shl reg/mem, imm8/cl   ;源操作数只能是8位立即数，或者CL寄存器，因为它们足够表达32或64了，其他的移位指令也是一样
> 将移出的位送进CF标志,空出的位用0填充
> 左移/右移

+ SAL/SAR
> sal是个例外，它不会扩展符号位的，直接将符号位移动，然后低位用0填充
> 算术左移动/算术右移
> 将移出的位送进CF标志,空出的位用原数据的符号位填充

+ ROL/ROR
> 将移出的值送入CF,然后再进行循环移位
> 循环左移动/循环右移动，可用于交换位组，比如26h向任何方向循环移动4位就会变成62h

+ RCL/RCR
> 带CF标志位的循环位移，如果右移，将最低位移动到CF标志位，然后CF标志位的内容移动到操作数的最高位，如此循环移位
> 带进位循环左移/带进位循环右移

> > 如果有符号操作数移动1位之后，符号位变了，则将OF置1。如果一次移动超过一位，那么OF标志是未定义的

+ SHLD/SHRD
> shrd reg/mem(16/32) , reg16/reg32  ,cl/imm8  ;源操作数和目的操作数宽度相同
> shld dest,src,count   ;目的操作数向左移动count指定的位数，送进CF标志，然后空出的位用src的高位填充，src不会被修改
> 双精度左移/双精度右移

乘除法

+ mul 无符号乘法
> reg/mem8/mem16/mem32  ;乘数和被乘数宽度一直，不能使用立即数，不会发生溢出
> 使用AL,AX,EAX 乘积分别在AX,DX:AX,EDX:EAX，如果乘积的高半部分不为0，则设置进位标志和溢出标志，用来检测是否可以安全的忽略高位

+ IMUL，有三种操作数模式
> imul reg/mem8/mem16/mem32  ;单操作数模式，和mul操作数一样
> imul reg16  ,reg/mem16/imm8/imm16  ;16位双操作数模式，将乘积放在第一个操做数中，必须是寄存器。乘数可以是寄存器，内存或者立即数
> imul reg32 , reg/mem32/imm8/imm32 ;32位双操作数模式。双操作数格式会按照目的操作数的大小来截断乘积，并保留符号位。如果被丢弃的是有效位，则溢出和进位标志置1
> imul reg16,reg/mem16 , imm8/imm16  ;16位格式三操作数模式。第二个操作数与第三个操作数相乘，结果放在第一个操作数，若乘积有效位被丢弃，则溢出和进位置1
> imul reg32,reg/mem32 ,imm8/imm32  ;32位格式
> 有符号乘法，将乘积低半部分符号位扩展到高半部分，保留符号位

+ div 无符号除法
> div reg/mem8/mem16/mem32 ;不能是立即数
> 8位除数，被除数在AX,除数是8位寄存器或者内存数，商在AL,余数在AH
> 16位除数，被除数在DX:AX,除数是16位内存或者寄存器，商在AX，余数在DX
> 32位除数，被除数在EDX:EAX,除数是32位寄存器或者内存，商在EAX,余数在EDX

+ idiv
> 与无符号除法几乎相同，但是在执行除法之前，必须对被除数进行符号位扩展，也就是将EAX的符号,扩展到EDX
> 有符号除法,余数的符号总是与被除数相同
> > 执行除法之后，所有的符号标志都是未定义的
> > 执行除法后，商可能会导致溢出，这会使处理器发生异常中断

CBW/CWD/CDQ
> cbw ;无操作数，将AL的符号位扩展至AH
> cwd ;无操作数，将AX的符号扩展至DX
> CDQ ;同上，将EAX的符号位扩展至EDX


STC/CLC
> 设置/清除进位标志

## 操作数
+ 立即数
+ 寄存器
+ 内存

reg/reg8/reg16/reg32   通用寄存器，8位寄存器，16位寄存器和32位寄存器
sreg  16位段寄存器
imm/imm8/16/32   立即数，8/16/32位立即数
reg/(mem8/mem16/mem32)  8位操作数，可以是8位通用寄存器或者内存地址
mem   8/16/32位内存


## 寻址
> 寄存器寻址，操作数在寄存器中
> 直接寻址，操作数在地址中，直接给出内存地址(一个立即数)
> 基址寻址，使用寄存器给出内存地址来间接找到操作数
> 变址寻址，使用寄存器加上偏移量组合成内存地址来间接找到操作数

## 伪指令
> offset 表示一个变量与其所在段起始地址之间的距离
> PTR 指定操作数大小
> TYPE 返回一个操作数或数组中每个元素的大小，以字节计
> LENGHTOF 返回数组中元素的个数
> SIZEOF 返回type*lemght相乘的字节数
> LABEL 可以定义一个变量标号但是不分配空间
> ALIGN 将变量对齐到指定的字节边界
> TYPEDEF 自定义数据类型

## 示例代码

+ 0,程序模板

```asm
.386
.model flat,stdcall
.stack 4096
ExitProcess PROTO, dwExitCode:DWORD
.data
    ;声明变量
.code
main PROC
    ;指令代码
    INVOKE ExitProcess,0
main ENDP
END main


```

+ 1，整数加减法

```asm
.386 
.model flat,stdcall
.stack 4096
ExitProcess PROTO,dwExitCode:DWORD
.data
sum DWORD 0
.code
main PROC
mov eax,5;
add eax,6;
mov sum，eax;
INVOKE ExitProcess,0
main ENDP
END main

```

+ 字母大小写转换
```asm
;字母的ascll只有位5是不同的，所以只要进行逻辑与就行了
01100001 'a'
01000001 'A'
11011111 将小写字母和这个数与就能转换成大写
```


## 调用约定
> fastcall,使用寄存器传递参数

x32调用规范
+ c调用规范-,unix/windows
> 参数从右到左入栈,由主调函数清零堆栈. 具体做法是,在被调函数返回后,也就是call指令后,将esp加上压入栈中的参数总大小,即可快速完成堆栈清零

+ stdcall, win api函数使用此规范
> 参数逆序入栈,由被调函数清零堆栈
```asm
fun:
    push ebp
    mov ebp,esp
    mov eax,[ebp+12];第二个参数
    mov ecx,[ebp+8] ;第一个参数
    pop ebp         ;弹出ebp
    ret 8           ;从栈中弹出返回地址并清理堆栈
fun end

```

win x64调用规范,既用于c/c++,也用于win api
> 前四个参数依次存入RCX,RDX,R8,R9,其他参数依次从左到右顺序入栈
> 长度不足64位的参数不进行0扩展,因为高位是不确定的
> 小于64位的返回值放在RAX
> 大于64位的返回值存放在运行时堆栈,用RCX指出位置
> 主调用者在调用堆栈中分配32字节的影子空间，这样被调用程序就可以选择将寄存器参数保存在这个区域中
> 在调用子程序之前，堆栈指针必须是16字节边界对齐的，因为call指令会把8字节的返回地址压入堆栈，导致堆栈不是16字节对齐，所以栈指针除了32字节的影子空间还有在减去8，使其保持16字节对齐
> 主调程序负责清理堆栈
> RAX,RCX,RDX,R8,R9,R10,R11由主调程序保存,因为它们常用作返回值或者其他指示用途
> RBX,RBP,RDI,RSI,R12-R15由被调程序保存,它们常被子程序用于程序的执行操作


win32 api不保存EAX,EBX,ECX,EDX,所以需要调用者自己保存
