# C记录

1 字面量,会默认进行向上转换.字符型转换成int型,浮点型转换成double型,除非显示指定后缀明确类型

2 整数和浮点比较时,要注意精度舍弃问题,以及十进制和二进制互相转换后再表示的问题,0.1+0.2!=0.3就像这种十进制转二进制,小数表示是有误差的,所以最好相减对比绝对值的差值

3 表达式的值就是整个表达式执行之后的最后一个值,遇到,号和赋值时,要注意赋值运算符比,号优先级高

5 EOF是c用来表示函数以及遇到了文件结尾,并不是真正的结尾符号,是对系统的文件结尾的一种对应

6 数组初始化可以={} 或者使用指定初始化{[2]=3,5},定义数组必须指明一个常量.int [] 这种不指明大小的形式,只能用在函数定义或结构中用来表明步长的,因为会被转换成指针，

7 指针加减是以指针类型的大小为步长,指针表示多维数组的时候,要注意各级指针的步长,系统无法自动判断多级指针的步长,或者也可以转换成带步长的指针数组

0 操作链表时也可以传入链表的结束位置，前提不是循环链表

8 对于数组取值时,使用指针表示法,编译器更容易生成优化的代码

0 对于常规const，在c里面只起到限定作用，而不是真的常量,c++是真常量,可以用在声明数组大小中

0 声明一个二维数组指针 int (*a)[10]，之所以声明成这样是因为优先级问题

0 对于多维数组来说，如果用多级指针操作的话，要注意多级指针的步长

0 c99支持可变数组，数组都是在栈上分配的，一次性太大会栈溢出报错，这种数组不能初始化 int myarray(int row,int col,int array`[row]`[col]);

0 复合字面量 (int []){3,4},前者是省略名字之后的复合字面量的类型，编译器会自动计算大小。而且这种类型可以直接赋值给数组


0 数组用字符串常量初始化时，此数组存的是字符串的一个副本，但是随后可以任意修改

0 使用指针指向字符串常量，只能获得字符串常量的地址，却不能修改值

0 函数作用域指的是goto标签,函数不能使用,只有goto关键字能使用

0 函数外的变量及函数名都是文件作用域,直到文件结束

0 c符号链接性默认是外连接,局部的是无连接,除非使用static显示声明为文件内链接.这是对于全局变量或者函数而言的

0 对于局部变量,它的意思是此变量是静态存储的,永久性变量,使用static声明的局部变量,其实编译时会移到函数外面,成为一个块作用域的全局变量

0 register请求将此变量用寄存器操作,作为函数形参时,表示此此变量用寄存器传递.用它声明的变量不能取地址

0 外部变量只能使用常量初始化

0 int const * name和const int * name是一样的,都表明name的内容是常量

0 如果static const int name声明在一个头文件中,其他文件包含这个文件,就会获得该变量的一个副本,相当于每个文件都定义了一个这个变量,因为static是文件内可见的

0 volatile可以防止编译器优化

0 restrictb只能用于指针,表示指针是访问该数据的唯一方式,用于优化合并指针操作

0 int fun(int num[static 20]) static新增的含义,用在函数定义中表示限定参数至少有20个元素.为优化提供帮助.因为数组默认是用指针来传递,所以只能用这种方式来告诉编译器,数组的大小

0 结构初始化可以使用数组的初始化的方式,或者使用结构初始化器 如struct book name={.val=0,.str="aaa"};

0 结构默认是按值传递的,传递的是一个副本,早期结构是不能传递的,只能用指针,现在可以了

0 结构名是地址的别名,直接使用代表的是其内容,也就是第一个元素,要获得地址本身还是要&,而数组名就是地址本身,直接使用还是地址

0 首先要清楚,普通变量直接使用变量名获得的是变量里面的内容

0 允许把结构赋值给另一个结构,结构可以做为参数传递或者返回,这时候都会被翻译成一个副本

0 复合字面量为创建匿名结构体提供了一种方式,(struct book){val=1,val2=2}
```
struct book{
    int num;
    int [];//伸缩型数组成员,使用时自己去动态申请内存

};
```
0 最新标准可以直接在结构体内嵌套定义结构体

0 并且嵌套定义的结构体可以在外部直接使用其定义新类型，但是c++必须使用成员运算符，而且c++中使用结构体前面可以不加struct

0 c枚举变量可以使用自增运算符,但是c++不行

0 define 是文本级的替换,可以用于任何形式,但其作用域预编译时,用来定义类型别名的时候,不会进行类型检查,而且在定义多变量的时候也不如typedef来的好,是编译级支持

```
#define INT int
INT a,b;
= int a;
      b;//b没有类型

```
0 typedef只能用于类型

0 位运算,不会修改原值,而是会创建一个新值

0 掩码是几位得到的就是几位的值

0 要想重定义宏,必须和原宏一致.否则只能使用#undef取消后再重定义

0 最好不要用对宏的参数使用自增或者自减运算符,并且定义的时候要保证足够多的括号

```
    #define square(x) ((x)*(x));最好定义成这种
    100/square(10+5)
=>  100/((10+5)*(10+5));像这样才能避免优先级问题
    
    

```

0 #运算符和##运算符,前者表示将标记替换成字符串形式,后者表示链接两个标记变成一个新标记
```
  #define str(n) printf(#n ":%d",x##n);
  str(3)
=> printf("3:%d",x3);

```
0 变参宏...和__VA_ARGS__
```
#define print(num,...) printf(num,__VA_ARGS__);
print("%d,%f",23,.9)
=>printf("%d,%f",23,9);

```

defined运算符,测试宏是否定义过,并返回0,1.较新的编译器支持
```
#if defined (MAK)


```

define,ifdef,ifndef,else endif,undef,if ,elif ,else endif,defined

#line 100  or  line 21 "main.c"  重置__LINE__ 和 __FILE__ 返回的行号和文件名
#error 发出一个错误
#pragma c9x on 发送给编译器用的指令
#_Pragma("c9x on") 相当于上面的

# 预定义宏
```
    __DATE__ 预编译日期
    __TIME__ 编译代码的时间
    __FILE__ 当前源代码文件名
    __LINE__ 当前在源代码文件中的行号
    __STDC__ 为1时,表明实现遵循C标准
    __STDC_HOSTED__ 本机环境设置为1否则为0
    __STDC_VERSION__ 支持的标准
    __func__ 当前函数名   这是个预定义标识符

```

0 C11 泛型选择  关键字 _Generic   根据不同的类型选择不同的函数
```
#define typeinfo(x) _Generic(x, \
    int : #x":int",\
    default : #x" default"\
)

int temp = 4
typeinfo(temp);

=> "temp int"


```


0 inline 内联函数, 无法获取地址,如果强制获取地址,会无法生成内联函数.内联函数最好定义在头文件,一般不能将函数定义放入头文件,但是内联是个例外,因为它具有内部连接性,一般和static配合使用，并且可以多重链接性定义,c++不允许

0 _Noreturn 用来函数说明关键字,表示此函数调用后不再返回主调函数.用于函数,生成优化代码

0 void类型的指针在c中可以不强制转换就能赋给具体类型,而c++则必须要强制转换

0 assert 动态断言,执行期

0 _Static_assert(BIX_MAX==256,"error");静态断言,编译期

0 可变参数stdarg
```c
int myfun(int am,...){
    va_list ap,bp;
    char *a,*b;
    va_start(ap,am);
    va_copy(bp,ap);
    a = va_arg(ap,int);
    b = va_arg(ap,int);
    va_end(ap);
]
```



# c++记录

  * 函数没有参数默认void,main默认返回0 即return 0;仅限main
  * 头文件没有扩展名
  * 使用c++本身的代码文件注意命名空间
  * const相当于c中的#define
  * int a(5) 或 int a={0} int a{}c++的新初始化方式,都是一种初始化方式,没有数值默认为0
  * char 默认可能有符号也可能没有符号,要想确定除非指定符号
  * wchar_t name = L'b';可变字符
  * char16_t/char32_t  name = u/U't';固定长度
  * const 是真常量,后期无法通过地址修改
  * 注意变量计算时的变量提升,会编译成先用更大的变量计算,然后再将结果转换成目标的变量类型
  * sizeof返回的是字节数 
  * 可以这样定义一个数组char ch[]{'a','b'};
  * 不允许缩窄转换
  * 原始字符串 R"+* str *+"   这里面的字符将按照原来的字符显示，R"( str )" 这中无法显示括号
  * 可以创建没有类型名的结构体struct {string name;int age;} info;
  * 对空指针使用delete 或者 free是安全的
  * 对于使用int *name = new int[10] 这种格式分配的内存,应当使用delete [] name来释放,而如果是为一个类实体分配内存,则使用delete不带方括号
  * 对于多维数组,数组名代表数组首元素的地址,如果使用运算,那么每次的变化是首元素的字节数,而&数组,代表的是整个数组,使用运算,每次增加整个数组的大小
  * (*name).value 对于指针对象可以方式 name->value
  * for(int x : array) or for(double d : {3,4,5}) 基于范围的循环
  * 逻辑||和&&是个序列点,这表示左边如果有自增,则会使用自增后的运算符
  * switch 的case 无法处理浮点数据
  * 虽然函数不能直接返回数组,但是可以作为结构或者对象的成员来返回
  * c++ 函数不指定参数需要显式使用... 而c中这是默认的.并且如果实参与形参不匹配c++会自动转换成相同的类型,而c中只会截断
  * 在函数形参中 int a[] 和 int *a是等价的
  * 内联函数不能递归
  * int &a = b; 左值引用是标签级别的赋值,标签指向同一内存地址,在定义时初始化完成，只会再对其赋值就是操作标签指向的数据，如果引用形参和实参不一样，那么会生成一个临时匿名变量，并引用。
  * int &&a = 3 * b + 4;右值引用；引用常量
  * 默认参数 出现在还是原型中，并且只能从右到左依次定义默认参数，不能跳过。
  * 函数重载返回值可以不同，但这不是重载，只有参数特征不同才算是重载。也要注意没有完美匹配的时候自动转换问题，如果有多个可以转的就会报错，并且const和非const参数是算作重载的，注意引用可非引用被是不允许的，它们被视为同一特征标
  * 函数模板,typename和class 是一样的效果，老式实现是class，模板定义可以放在头文件中,可以重载
  
```c++
  template <typename T>
      T swap(T &a , T &b,int num){
        a ^= b;
        b = a ^ b;
        a ^= b;
        T c = a;
        return num;
  }
  p
  int a =10,b=99;
  swap(a,b,2);

```


  * 函数优先级 非模板函数 > 显式具体化函数 > 显式实例化 > 模板函数(隐式实例化化)，这些之间可以互相重载。实例化是声明就够了，而具体化还需要有单独的定义。当同一种类型的显式具体和显式实例同时存在将会出错
  
```c++
    int swap(int &a,int &b);
    
    template<class T>
    void swap(T &a , T &b);
    
    template<>
    swap<int>(char (&a)[][3] , char (&b)[][3]);
    or
    template<> swap(char (&a)[][3] , char (&b)[][3]);  //swap的类型参数是可选的，因为可以根据后面的参数类型自动推断


    template swap<double>(double &a , double &b);
    template swap(char &a , char &b);
    
    swap<>(1,3);可以主动选择使用模板函数
    swap<int>(1.5,9.7)

```

  * 重载时优先级选择问题
    
    1 const参数和非const参数同时存在时，不会产生二义性的只有指针或者引用的情况，因为如果是普通变量，那么声明为const没有意义，毕竟都是局部变量
    2 当没有与实参完全匹配的函数时，会进行变量转换，提升转换优先于标准转换，需要进行转换的越少的函数越趋向于具体
    3 要注意完全匹配和最佳匹配的概念，完全匹配是指参数能够完美的配合，而最佳是指在完全匹配的基础上又能够指出更具体的内容，最佳优先于完全
    
  * 如果是多个参数的模板，想要返回类型可以使用后置返回类型，以及decltype关键字
  
  ```cpp
      template<class T1 , typename T2>
      auto swap(T1 a, T2 b)->decltype(a+b)
      {
        decltype(b+a) c = b +a;
        return c;
      }
  
  ```
  
  * decltype的类型决策是根据正常类型，函数返回值，以及左值（就是用括号括起来 如 decltype((T1+T2)) name  那么name就是一个引用类型）这个顺序来的
