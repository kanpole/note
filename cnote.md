# C记录

1 字面量,会默认进行向上转换.字符型转换成int型,浮点型转换成double型,除非显示指定后缀明确类型

2 整数和浮点比较时,要注意精度舍弃问题,以及十进制和二进制互相转换后再表示的问题,0.1+0.2!=0.3就像这种十进制转二进制,小数表示是有误差的,所以最好相减对比绝对值的差值,而已因为是二进制,所以增加或者缩小2倍就可以左移或者右移一位

3 表达式的值就是整个表达式执行之后的最后一个值,遇到,号和赋值时,要注意赋值运算符比,号优先级高.并且要注意序列点

6 数组初始化可以={} 或者使用指定初始化{[2]=3,5},定义数组必须指明一个常量.  int [] 这种不指明大小的形式,只能用在函数定义或结构中用来表明步长的,因为会被转换成指针，

7 指针加减是以指针类型的大小为步长,指针表示多维数组的时候,要注意各级指针的步长,系统无法自动判断多级指针的步长,或者也可以转换成带步长的指针数组

0 对于多维数组来说，如果用多级指针操作的话，要注意多级指针的步长

8 对于数组取值时,使用指针表示法,编译器更容易生成优化的代码

0 对于常规const，在c里面只起到限定作用，而不是真的常量,而在c++中可以用在声明数组大小中

0 声明一个二维数组指针 int (*a)[10]，之所以声明成这样是因为优先级问题

0 c99支持可变数组，数组都是在栈上分配的，一次性太大会栈溢出报错，这种数组不能初始化 int myarray(int row,int col,int array[row][col]);

0 复合字面量 (int []){3,4},前者是省略名字之后的复合字面量的类型，编译器会自动计算大小。而且这种类型可以直接赋值给数组

0 数组用字符串常量初始化时，此数组存的是字符串的一个副本，随后可以任意修改

0 使用指针指向字符串常量，只能获得字符串常量的地址，却不能修改值

0 函数作用域指的是goto标签,函数不能使用,只有goto关键字能使用

0 函数外的变量及函数名都是文件作用域,直到文件结束

0 c符号链接性默认是外连接,局部的是无连接,除非使用static显示声明为文件内链接.这是对于全局变量或者函数而言的

0 对于局部变量,它的意思是此变量是静态存储的,永久性变量,使用static声明的局部变量,其实编译时会移到函数外面,成为一个块作用域的全局变量

0 register请求将此变量用寄存器操作,作为函数形参时,表示此此变量用寄存器传递.用它声明的变量不能取地址

0 外部变量只能使用常量初始化

0 int const * name和const int * name是一样的,都表明name的内容是常量

0 如果static const int name声明在一个头文件中,其他文件包含这个文件,就会获得该变量的一个副本,相当于每个文件都定义了一个这个变量,因为static是文件内可见的

0 volatile可以防止编译器优化,不要使用合并操作

0 restrictb只能用于指针,表示指针是访问该数据的唯一方式,用于优化合并指针操作

0 int fun(int num[static 20]) static新增的含义,用在函数定义中表示限定参数至少有20个元素.为优化提供帮助.因为数组默认是用指针来传递,所以只能用这种方式来告诉编译器,数组的大小

0 结构初始化可以使用数组的初始化的方式,或者使用结构初始化器 如struct book name={.val=0,.str="aaa"};

0 结构默认是按值传递的,传递的是一个副本,早期结构是不能传递的,只能用指针,现在可以了

0 结构名是地址的别名,直接使用代表的是其内容,也就是第一个元素,要获得地址本身还是要&,而数组名就是地址本身,直接使用还是地址

0 首先要清楚,普通变量就是一个地址的标签,使用变量名就相当于显式标签地址的内容

0 允许把结构赋值给另一个结构,结构可以做为参数传递或者返回,这时候都会被翻译成一个副本

0 复合字面量为创建匿名结构体提供了一种方式,(struct book){val=1,val2=2}
```
struct book{
    int num;
    int [];//伸缩型数组成员,使用时自己去动态申请内存

};
```
0 最新标准可以直接在结构体内嵌套定义结构体

0 并且嵌套定义的结构体可以在外部直接使用其定义新类型，但是c++必须使用作用域运算符，而且c++中使用结构体前面可以不加struct

0 c枚举变量可以使用自增运算符,但是c++不行

0 define 是文本级的替换,可以用于任何形式,但其作用域预编译时,用来定义类型别名的时候,不会进行类型检查,而且在定义多变量的时候也不如typedef来的好,是编译级支持

```
#define INT int
INT a,b;
= int a;
      b;//b没有类型

```
0 typedef只能用于类型

0 位运算,不会修改原值,而是会创建一个新值

0 要想重定义宏,必须和原宏一致.否则只能使用#undef取消后再重定义

0 最好不要用对宏的参数使用自增或者自减运算符,并且定义的时候要保证足够多的括号

```
    #define square(x) ((x)*(x));最好定义成这种
    100/square(10+5)
=>  100/((10+5)*(10+5));像这样才能避免优先级问题
    
    

```

0 #运算符和##运算符,前者表示将标记替换成字符串形式,后者表示链接两个标记变成一个新标记
```
  #define str(n) printf(#n ":%d",x##n);
  str(3)
=> printf("3:%d",x3);

```
0 变参宏...和__VA_ARGS__
```
#define print(num,...) printf(num,__VA_ARGS__);
print("%d,%f",23,.9)
=>printf("%d,%f",23,9);

```

defined运算符,测试宏是否定义过,并返回0,1.较新的编译器支持
```
#if defined (MAK)


```

define,ifdef,ifndef,else,undef,if ,elif ,else endif,defined

#line 100  or  line 21 "main.c"  重置__LINE__ 和 __FILE__ 返回的行号和文件名
#error 发出一个错误
#pragma c9x on 发送给编译器用的指令
#_Pragma("c9x on") 相当于上面的

# 预定义宏
```
    __DATE__ 预编译日期
    __TIME__ 编译代码的时间
    __FILE__ 当前源代码文件名
    __LINE__ 当前在源代码文件中的行号
    __STDC__ 为1时,表明实现遵循C标准
    __STDC_HOSTED__ 本机环境设置为1否则为0
    __STDC_VERSION__ 支持的标准
    __func__ 当前函数名   这是个预定义标识符

```

0 C11 泛型选择  关键字 _Generic   根据不同的类型选择不同的函数
```
#define typeinfo(x) _Generic(x, \
    int : #x":int",\
    default : #x" default"\
)

int temp = 4
typeinfo(temp);

=> "temp int"


```


0 inline 内联函数, 无法获取地址,如果强制获取地址,会无法生成内联函数.内联函数定义在头文件中,因为它具有内部连接性,一般和static配合使用，并且可以多重链接性定义,c++不允许

0 _Noreturn 用来函数说明关键字,表示此函数调用后不再返回主调函数.用于函数,生成优化代码

0 void类型的指针在c中可以不强制转换就能赋给具体类型,而c++则必须要强制转换

0 assert 动态断言,执行期

0 _Static_assert(BIX_MAX==256,"error");静态断言,编译期

0 可变参数stdarg
```c
int myfun(int am,...){
    va_list ap,bp;
    char *a,*b;
    va_start(ap,am);
    va_copy(bp,ap);
    a = va_arg(ap,int);
    b = va_arg(ap,int);
    va_end(ap);
]
```



# c++记录

  * 函数没有参数默认void,可以没有return,默认返回0;
  
  * 使用c++本身的代码文件注意命名空间
  
  * int a(5) 这种内置类型的单对象初始化 或 int a={0} int a{} 这种也可以用于单指,但主要用在列表初始化 都是c++的新初始化方式,没有数值默认为0
  
  * char 默认可能有符号也可能没有符号,要想确定除非指定符号
  
  * wchar_t name = L'b';可变字符
  
  * char16_t/char32_t  name = u/U't';固定长度
  
  * const 变量只能定义是初始化,后期无法通过地址修改
  
  * 注意变量计算时的变量提升,当两个数据不同时,会编译成先用更大的类型计算,然后再将结果转换成目标的变量类型
  
  * 可以这样定义一个数组char ch[]{'a','b'};
  
  * 原始字符串 R"+* str *+"   这里面的字符将按照原来的字符显示，R"( str )" 这中无法显示括号
  
  * 可以创建没有类型名的结构体struct {string name;int age;} info; 这种只能定义一次变量
  
  * 对空指针使用delete 或者 free是安全的
  
  * 对于使用int *name = new int[10] 这种格式分配的内存,应当使用delete [] name来释放,而如果是为一个类实体分配内存,则使用delete不带方括号
  
  * 对于多维数组,数组名代表数组首元素的地址,如果使用运算,那么每次的变化是首元素的字节数,而&数组,代表的是整个数组,使用运算,每次增加整个数组的大小
  
  * (*name).value 对于指针对象可以方式 name->value
  
  * for(int x : array) or for(double d : {3,4,5}) 基于范围的循环
  
  * 逻辑||和&&是个序列点,这表示左边如果有自增,则会使用自增后的运算符
  
  * switch 的case 无法处理浮点数据,并且需要显式break
  
  * 虽然函数不能直接返回数组,但是可以作为结构或者对象的成员来返回
  
  * c++ 函数不指定参数需要显式使用...,否则默认void 而c中这是默认的.并且如果实参与形参不匹配c++会自动转换成相同的类型,而c中只会截断

  * 内联函数不能递归,从汇编的角度思考就明白了
  
  * int &a = b; 左值引用是标签级别的赋值,标签指向同一内存地址,在定义时初始化完成，对其赋值就是操作标签指向的数据，如果引用形参和实参不一样，那么会生成一个临时匿名变量,不能引用右值,作为函数参数也不行
  
  * int &&a = 3 * b + 4;右值引用；引用常量,会新建一个变量然后引用.
  
  * 默认参数 出现在还是原型中，并且只能从右到左依次定义默认参数，不能跳过。
  
  * 函数重载不关心返回值,只有关心参数特征。也要注意没有完美匹配的时候自动转换问题，如果有多个转换后能匹配的函数就会报错，并且const和非const参数是算作重载的，注意引用和非引用被是不允许的，它们被视为同一特征标
  
  * 函数模板,typename和class 是一样的效果，老式实现是class，模板定义可以放在头文件中,可以重载
  
```c++
  template <typename T,class T2>
      auto swap(T &a , T2 &b, int num) -> decltype(a+b) {
        a ^= b;
        b = a ^ b;
        a ^= b;
        T c = a;
        return num;
  }
  p
  int a =10;
  double b=99;
  swap(a,b,2);

```


  * 函数优先级 非模板函数 > 显式具体化函数 > 显式实例化 > 模板函数(隐式实例化化)，这些之间可以互相重载。实例化是声明就够了，而具体化还需要有单独的定义。当同一种类型的显式具体和显式实例同时存在将会出错
  
```c++
    int swap(int &a,int &b);
    
    template<class T>
    void swap(T &a , T &b);
    
    template<>
    swap<int>(char (&a)[][3] , char (&b)[][3]);
    or
    template<> swap(char (&a)[][3] , char (&b)[][3]);  //swap的类型参数是可选的，因为可以根据后面的参数类型自动推断


    template swap<double>(double &a , double &b);
    template swap(char &a , char &b);
    
    swap<>(1,3);可以主动选择使用模板函数
    swap<int>(1.5,9.7)

```

  * 重载时优先级选择问题
    
    1 函数中const参数和非const参数同时存在时，不会产生二义性的只有参数是指针或者引用的情况，因为如果是普通变量，那么声明为const没有意义，毕竟都是局部变量
    2 当没有与实参完全匹配的函数时，会进行变量转换，提升转换优先于标准转换，需要进行转换的越少的函数越趋向于具体
    3 要注意完全匹配和最佳匹配的概念，完全匹配是指参数能够完美的配合，而最佳是指在完全匹配的基础上又能够指出更具体的内容，最佳优先于完全
    
  * 如果是多个参数的模板，想要返回类型可以使用后置返回类型，以及decltype关键字
  
  ```cpp
      template<class T1 , typename T2>
      auto swap(T1 a, T2 b)->decltype(a+b)
      {
        decltype(b+a) c = b +a;
        return c;
      }
  
  ```
  
  * decltype的类型决策是根据正常类型，函数返回值，以及右值（就是用括号括起来 如 decltype((T1+T2)) name  那么name就是一个引用类型）这个顺序来的
  
  * #define定义的符号是没有作用域的,只要在使用之前定义就行了
  * register关键字在c++中变得无意义,只是起到提示该变量是自动变量的作用
  * 有些编译器不允许初始化局部自动数组和结构,因为这需要生成额外的指令
  * 全局const的初始化可以使用非常量:const int a = func() * 5;是允许的
  * ::name;当在函数内以及函数外都有一个name变量时,这种方法表示使用外部的版本
  * 对于全局变量,在本文件内static声明的将覆盖外部的同名变量
  * mutable 可以改变const不能修改的限制
  ```c++
      struct my{
        int a;
        mutable char *b;
      };
      
      const my a={10,"ssa"};
      a.b= "sdf";    //使用mutable声明的变量允许修改
  ```
  
  * const变量默认内连接,可以使用extern指定为外链接.但是这样就只能有一个定义,不能放在头文件了
  * 对函数使用static必须对原型和定义同时使用
  * 语言连接性 extern "c" void fun();说明这是一个c函数,使用c的命名约定查找;   extern "c++" void fun()这是c++的默认省略
  * 定位new:  int bootload = new(0x7f78a) int[40] => new(sizeof(int)*40,0x7f78a)在指定位置分配内存,需要包含new头文件
  * using声明是单个指定:using std::cout,如果和局部或者全局出现同名就会报错.而using namespace std;是编译指令,可以一次性包含所有这个名称空间内的变量,并且如果和全局或者局部同名的话只会隐藏,不会报错.并且using编译指令是可以传递的既:a包含b b包含c  => a包含c.
  * namespace one{ namespace two{   namespace{     }      }     }  名称空间可以嵌套,并且可以声明匿名的名称空间,匿名的空间只能在定义它的文件中使用
  * 定义函数时,声明和定义都需要在同一个命名空间内


  * 类成员默认私有，而结构默认公有，其他行为于类相同
  * 定义函数时使用作用域解析运算符来标识所属的类,并且定义类的大括号之后要主要有一个分号表明结束
  * 类声明中的函数自动成为内联函数，当然也可以在类外使用inline来定义，但是内联函数要求每个使用它的文件都必须包含其定义，仅仅包含原型是不行的，所以还是在头文件中声明为好
  
  * 构造函数,如果没有提供构造，默认提供一个，否则就取消提供的默认构造。提供构造时候最好提供一个没有任何参数的，或者全带默认参数的的构造。构造可以有多个
  * 析构函数，一般用来释放new分配的内存，否则其实使用默认实现的空构造即可，构造不能有参数不能有返回值,析构一般不能显式调用。一般作用域过期之后，或者调用delete来是否new分配的对象时自动调用，析构只能有一个
```c++

  //正常初始化
  MyClass mc; //调用默认构造，调用默认构造时，不需要显式指定括号
  MyClass mc("sd"); //调用指定构造；
  MyClass mc = MyClass("sd");
  MyClass mc();表示函数声明
  
  //使用列表初始化
  MyClass mc{};
  MyClass mc{"ad"};
  MyClass *mc = new MyClass{"c"};
  
  
  ~MyClass(){}；
  
  //加入MyClass有一个void show();的函数原型则：
  const MyClass mc= MyClass{"ad"};
  mc.show();//是不允许的，因为对象是const 而编译器不知道show会不会修改对象。
  //把原型和定义改为 void show() const就可以了。这种后置const用在类成员函数里，表示不会修改对象
  
  
  //在一些编译器里，会出现创建临时对象的问题。所以最好使用第一种定义方式
  MyClass mc("ad"); //这种不会创建临时对象
  MyClass mc = Myclass("ad"); //这种可能会创建一个临时对象，然后把临时对象复制给mc接着再删除自己调用析构
  mc = MyClass("ad");  //这种肯定会创建一个临时对象，然后复制给mc
  
  //只有一个参数的构造可以这样调用；允许使用赋值语法构造一个对象
  MyClass mc = "ad";
  
  
  //注意一点，因为自动变量是在栈中分配的，所以析构的调用顺序是先进后出

```

  * this指针，每个类的成员函数包括构造和析构，都有一个隐藏的this指针，指向调用此函数的对象
  
```c++
    class my{
        private:
            int am;
        public:
          const  my & comp(const my & other) const {
              if(my.am>this.am)  //注意虽然am是my类的私有成员，不能通过对象调用，但是因为是在类内部，所以可以无视这种规则
              return *this;
          }
    }


```
  
  * 类数组，对于类数组的初始化，
```c++
    myclass mc[20];//分配空间时,调用默认构造
    myclass mc[3]={myclass("sd"),myclass("sd") };  //被省略的元素会调用默认的构造函数，定义并初始化数组的方案是先调用默认的构造函数定义出数组，然后大括号使用构造创建临时变量，并将值依次复制给对应元素 \
                                                   //通过对比数组字符串的赋值就明白了。 因为自动变量是在栈里面分配的，先需要确定空间，然后再运行代码进行构造对象。结果就导致了这样
  
```
  

  * 类内常量
```c++
  class my{
      const int pint = 12;//这是不对的，因为类声明并不是创建对象实体，所以无法存储这个常量的值，除非前面加上static使其成为静态变量
      enum {pint = 12}; //或者可以使用匿名枚举，作用域为整个类
      char *str[pint];
      
      enum a {S ， M , L};  
      enum b {S , M , L}'
      enum c = S;  //这两个普通枚举会造成枚举常量冲突
      
      //可以这样解决
      enum class a{S，M,L};  //可以使用struct代替class. 这种称为作用域枚举，底层类型默认为int型
      enum class b{S,M,L};
      enum c = a::S; //使用时只能显式指定所属的作用域,才能使用其枚举常量
      
      enum class : int a {S,M,L};  //作用域枚举可以改变底层类型
  }


```
  
  
  * 
