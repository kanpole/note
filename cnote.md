# C记录

1 字面量,会默认进行向上转换.字符型转换成int型,浮点型转换成double型,除非显示指定后缀明确类型
2 整数和浮点比较时,要注意精度舍弃问题,以及十进制转二进制表示的问题,0.1+0.2!=0.3就像这种十进制转二进制,小数表示是有误差的,所以最好相减对比绝对值的差值
3 表达式的值就是整个表达式执行之后的最后一个值,遇到,号和赋值时,要注意赋值运算符比,号优先级高
5 EOF是c用来表示函数以及遇到了文件结尾,并不是真正的结尾符号,是对系统的文件结尾的一种对应
6 数组初始化可以={} 或者使用指定初始化{{},{}},定义数组必须指明一个常量.int [] 这种不指明大小的形式,只能用在函数定义时
7 指针加减是以指针类型的大小为步长,指针表示多维数组的时候,要注意各级指针的步长,系统无法自动判断多级指针的步长
0 编写数组函数时，可以传入数组的起始位置，和结束位置
0 操作链表时也可以传入链表的结束位置，前提不是循环链表
8 对于数组取值时,使用指针表示法,编译器更容易生成优化的代码
0 对于常规const，在c里面只起到限定作用，而不是真的常量,c++是放到常量区.对于有些现代的编译器来说,有些是将const当作是真常量,可以用在声明数组大小中
0 声明一个二维数组指针 int (*a)[10]，之所以声明成这样是因为优先级问题
0 对于多维数组来说，如果用多级指针操作的话，要注意多级指针的步长
0 c99支持可变数组，数组都是在栈上分配的，一次性太大会栈溢出报错，这种数组不能初始化 int myarray(int row,int col,int array`[row]`[col]);
0 复合字面量 (int []){3,4},前者是省略名字之后的复合字面量的类型，编译器会自动计算大小。而且这种类型可以直接赋值给数组
0 &"abdfafa" 可以得到字符串首地址的值，不加&也可以
0 数组用字符串常量初始化时，此数组存的是字符串的一个副本，但是随后可以任意修改
0 使用指针指向字符串常量，只能获得字符串常量的地址，却不能修改值
0 函数作用域指的是goto标签,函数不能使用,只有goto关键字能使用
0 函数外的变量及函数名都是文件作用域,直到文件结束
0 c符号链接性默认是外连接,局部的是无连接,除非使用static显示声明为文件内链接.这是对于全局变量或者函数而言的
0 对于局部变量,它的意思是此变量是静态存储的,永久性变量,使用static声明的局部变量,其实编译时会移到函数外面,成为一个仅此函数可见的全局变量
0 register请求将此变量用寄存器操作,作为函数形参时,表示此此变量用寄存器传递.用它声明的变量不能取地址
0 外部变量只能使用常量初始化
0 int const * name和const int * name是一样的,都表明name的内容是常量
0 如果static const int name声明在一个头文件中,其他文件包含这个文件,就会获得该变量的一个副本,相当于每个文件都定义了一个这个变量,因为static是文件内可见的
0 volatile可以防止编译器优化
0 restrictb只能用于指针,表示指针是访问该数据的唯一方式,用于优化合并指针操作
0 int fun(int num[static 20]) static新增的含义,用来限定参数至少有20个元素.为优化提供帮助
0 结构初始化可以使用数组的初始化的方式,或者使用结构初始化器 如struct book name={.val=0,.str="aaa"};
0 结构默认是按值传递的,传递的是一个副本,早期结构是不能传递的,只能同指针,现在可以了
0 结构名是地址的别名,直接使用代表的是其内容,也就是第一个元素,要获得地址本身还是要&,而数组名就是地址本身,直接使用还是地址
0 首先要清楚,普通变量直接使用变量名获得的是变量里面的内容
0 允许把结构赋值给另一个结构,结构可以做为参数传递或者返回,这时候都会被翻译成一个副本
0 复合字面量为创建匿名结构体提供了一种方式,(struct book){val=1,val2=2}
```
struct book{
    int num;
    int [];//伸缩型数组成员,使用时自己去动态申请内存

};
```
0 最新标准可以直接在结构体内嵌套定义结构体
0 并且嵌套定义的结构体可以在外部直接使用其定义新类型，但是c++必须使用成员运算符，而且c++中使用结构体前面可以不加struct
0 c枚举变量可以使用自增运算符,但是c++不行
0 define 是文本级的替换,可以用于任何形式,但其作用域预编译时,用来定义类型别名的时候,不会进行类型检查,而且在定义多变量的时候也不如typedef来的好,是编译级支持
```
#define INT int
INT a,b;
= int a;
      b;//b没有类型

```
0 typedef只能用于类型
0 位运算,不会修改原值,而是会创建一个新值
0 掩码是几位得到的就是几位的值
0 要想重定义宏,必须和原宏相同顺序也一样.否则只能使用#undef取消后再重定义
0 最好不要用对宏使用自增或者自减运算符,并且定义的时候要保证足够多的括号
```
    #define square(x) ((x)*(x));最好定义成这种
    100/square(10+5)
=>  100/((10+5)*(10+5));像这样才能避免优先级问题
    
    

```

0 #运算符和##运算符,前者表示将标记替换成字符串形式,后者表示链接两个标记变成一个新标记
```
  #define str(n) printf(#n ":%d",x##n);
  str(3)
=> printf("3:%d",x3);

```
0 变参宏...和__VA_ARGS__
```
#define print(num,...) printf(num,__VA_ARGS__);
print("%d,%f",23,.9)
=>printf("%d,%f",23,9);

```

defined运算符,测试宏是否定义过,并返回0,1.较新的编译器支持
```
#if defined (MAK)


```

define,ifdef,ifndef,else endif,undef,if ,elif ,else endif,defined

#line 100  or  line 21 "main.c"  重置__LINE__ 和 __FILE__ 返回的行号和文件名
#error 发出一个错误
#pragma c9x on 发送给编译器用的指令
#_Pragma("c9x on") 相当于上面的

预定义宏
```
    __DATA__ 预编译日期
    __TIME__ 编译代码的时间
    __FILE__ 当前源代码文件名
    __LINE__ 当前在源代码文件中的行号
    __STDC__ 设置为1时,表明实现遵循C标准
    __STDC_HOSTED__ 本机环境设置为1否则为0
    __STDC_VERSION__ 支持的标准
    __func__ 当前函数名   这是个预定义标识符

```

0 C11 泛型选择  关键字 _Generic
```
#define typeinfo(x) _Generic(x, \
    int : #x":int",\
    default : #x" default"\
)

int temp = 4
typeinfo(temp);

=> "temp int"


```


0 inline 内联函数, 无法获取地址,如果强制获取地址,会无法生成内联函数.内联函数最好定义在头文件,一般不能将函数定义放入头文件,但是内联是个例外,因为它具有内部连接性,一般和static配合使用.C允许内联函数的多重链接性定义,c++不允许

0 _Noreturn 用来函数说明关键字,表示此函数调用后不再返回主调函数.用于函数,生成优化代码
0 void类型的指针在c中可以不强制转换就能赋给具体类型,而c++则必须要强制转换
0 assert 动态断言,执行期
0 _Static_assert(BIX_MAX==256,"error");静态断言,编译期
0 可变参数stdarg
```c
int myfun(int am,...){
    va_list ap,bp;
    char *a,*b;
    va_start(ap,am);
    va_copy(bp,ap);
    a = va_arg(ap,int);
    b = va_arg(ap,int);
    va_end(ap);
]
```
