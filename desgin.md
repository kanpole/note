# 设计模式个人理解

## 单例模式 Singleton 创建型

```c
    将类的构造函数设为私有,并且增加一个类下的静态函数,和对象.使用时直接用函数返回对象
    一般用在只需要一个对象实力存在时.
    场景:比如资源池
      
```


## 迭代器模式 Iterator 行为型

```c
    构造一个本集合类型的迭代器类
    为集合创建一个函数,此函数返回迭代器,之后对集合的操作可以使用迭代器
    一般需要,hasNext(),next();
    场景:用于隐藏集合的循环逻辑
```

## 适配器/包装器模式  Adapter/Wrapper 结构型

```c
    通过继承或者包含父类,实现一些父类没有实现的东西.
    场景:一个类要求必须实现一大堆接口,非常麻烦,可以用一个适配器类来默认实现.

```

## 模板方法模式 Template method 行为型

```c
    父类创建一个主方法和方法子,主方法调用方法子来构建步骤.方法子由子类负责实现
    场景:游戏场景的摆放,一些列摆放步骤相同,但是具体摆放时的表现由模型自己决定
```

## 工厂模式 Factory 创建型

```c
    工厂和产品之间可以毫无关联，工厂类创建一个主方法，和方法子，子类负责实现，并且创建相应的产品
    场景：粒子系统和特效系统具有相同工作模式，但是它们的具体表现却不同，而且也不是同一个产品类
```

## 抽象工厂模式 Abstract Factory 创建型

```c
    工厂不再提供主方法，其中的每个方法都是一个创建某个产品的对象的方法，相当于每个方法都是一个独特的加工工艺，当然也可以提供主方法。
    场景：用于多对多的复杂关系，比如用同一种数据结构生成html文档类型和json类型

```


## 原型模式 Protype 创建型

```c
    提供一个原型对象，然后通过一系列操作，复制原型的对象并返回。可以调用对象本身的的复制实现，也可以用重新创建一个对象，并将状态复制过来
    场景：比如影子系统，想要一个和玩家一模一样的角色。可以使用原型方法复制出来

```

## 建造者模式 Builder 创建型

```c
    builder类提供了一系列方法，创建者通过包含builder对象，进行内部构建，然后再返回
    场景：比如Java的stringBuilder类
    
```


## 桥接模式 Bridge 结构型

```c
    将类的实现层次与功能层次分离，一边通过继承，一边通过包含对象。实现层调用功能层的对象来实现功能
    场景：游戏角色的状态，与角色的技能

```

## 策略模式 Strategy 行为型

```c
    数据和算法分离，不同的状态可以主动切换策略的实现来展现不同的行为
    场景：Boss的攻击行为，会随玩家职业选择对应的应对策略，每个策略通常是一整套固定行为

```

## 组合模式 Composite 结构型

```c
    通过子类包含父类对象，实现复合型结构，就是可以递归的结构，适用于用于相同基属性的场景
    场景：文件和文件夹

```


## 装饰模式 Decoratory 结构型

```c
    通过继承并且包含被装饰对象，来实现增加被装饰对象的功能
    场景：给角色各部位装上装备

```

## 访问者模式 Visitor 行为型

```c
    被访问的类提供accept()函数，接受一个访问者，并调用访问者的visitor函数,然后访问者就可以通过传回的对象进行一些访问操作。期间可以有一个监视器类管理访问
    场景：一个对象只有在某些情况下才允许访问，并且访问者本身不需要存储数据
```

## 责任链模式 Chain of Responsibility 行为型

```c
    通过包含自己来实现，责任链包含一个自己的对象next,使用时设置next对象，形成一个责任链
    场景：shard的渲染管线

```

## 窗口模式 Facade 行为型

```c
    化繁为简，将一些列复杂操作，通过封装在一个简单的接口使用。
    场景：动态网页的生成，需要链接数据库，生成网页等一系列操作封装到一起


```

## 中介者模式 Mediator 行为型

```c
    被调停者包含中介者对象，中介者包含所有的调停者，在使用时互相设置好彼此，需要沟通时，通过调用中介者的函数来进行。
    场景：登录系统中各表单互相牵连的复杂逻辑通信

```

## 观察者模式 Observer 行为型

```c
    被观察者包含一个观察者的集合，使用时向这个集合注册观察者，当某些情况发生时，就循环这个集合，调用观察者提供的函数
    场景：游戏中Boss的血条状态

```

## 备忘录模式 Memento 行为型

```c
    目标通过包含一个自身的状态类对象，在需要时创建一个对象，并将自己的状态保存进去。在需要时可以恢复这个状态
    场景：游戏的存储机制

```

## 状态模式 State 行为型

```c
    状态本身就是一个类，然后在状态内部，会根据当前状态返回合适的状态对象。不需要外来干预，因为是状态自动生成相应的状态对象，所以需要提取指定有多少中状态
    场景：角色的行为树
```

## 共享模式 Flyweight 结构型

```c
    通过建立一个内存池，也就是一个集合，这个集合存储各种对象，当需要某个对象时，就到池里查询，有就之间返回，没有就创建
    场景：数据库链接池

```

## 代理模式 Proxy 结构型

```c
    代理器通过继承并包含被代理者对象实现，如果代理器想处理就处理，不能处理就转发给原对象
    场景：vpn
```

## 命令模式 Command 行为型

```c
    将命令封装成一个类，这个类包含需要操作的对象，以及具体命令类的操作方法，转交给执行器执行
    场景：事件驱动中事件消息

```

## 解释器模式 Interpreter 行为型

```c
    通过构建语法树，建造一个解释器，解释器负责解析语法文本并执行相应操作
    场景：脚本语言

```

##  行为模式

    - 创建型:一般是创建出对象的模式，隐藏new以及复杂的创建逻辑，提供方法创建出对象。使得根据情况创建需要的对象更加灵活
    - 结构型:关心的是类和对象之间的组合，接口的定义，以及对象扩展新功能的方式
    - 行为型:主要解决对象与对象之间的通信与协作


# 准则

    + 开闭原则：对修改关闭，对扩展开放
    + 里氏替换原则：基类出现的地方，子类一定可以出现
    + 依赖倒置原则：依靠接口编程，而不是依赖于具体类
    + 接口隔离原则：将多个不相干的功能，分别封装在不同的接口中，避免混乱
    + 迪米特原则：又称最少知道原则，尽可能少的暴漏信息，尽量不要与其他对象或类发生太多关系
    + 合成复用原则：多使用合成，聚合，少用继承
